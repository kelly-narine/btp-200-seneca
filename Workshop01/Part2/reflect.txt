
While creating this application one of the errors I have encountered early on was having extra memory addresses printed with the output of my marksArr array of marks. With the guidance of Visual Studio's debugging feature, I was able to trace the array's results iteration by iteration, which lead to figuring out that an error was made with the amount of iterations specified in the for-loop. Another challenge encountered involved was an input buffer error, which would occur after entering the name of the file that needs to be read or at times opting to exit the the application. After debugging and reading through the descriptions of the functions, I came to the realization that I was making use of one object of type Mark rather than an array of objects of type Mark. 

Reference of variables by address is another concept learnt. In the process of creating the sortMarks function, I was initally looping-through the arrays and swapping variables by value, rather than the reference to the address. Because of this, the swapping was not working correctly. After referencing two marks that was taken during the iteration of the for-loop looping through the arrays of marks, I created a pointer for each Mark that would point to their address. I then dereferenced them to to obtain their value from the address so that the values can be relocated to the appropriate address. 

Stable Bubble Sorting algorithm is another concept learnt. This was applied to the sortMarks function. Not only does it sort the Mark objects based on the mark in descending order, but also keeps multiple Mark objects with same mark associated with in the order the data was read at. 

If the main function was to go inside the seneca namespace, it will not be able to compile as a result of compilation errors. Modular programming is beneficial because of its readability. It is easier to work with / debug code that are broken down into parts in comparison to code that is all contained within a single file. 
