Throughout this workshop, there are a few concepts learnt to be noted. If we were to not overload the insertion operator in the SavingsAccount, which is the Derived class of BankAccount (Base Class), the output will remain the same for the BankAccount portion, but SavingsAccount portion will be missing (i.e interest rate, interest rate date). This is due to the overloaded insertion operator from BankAccount getting called instead, which happens to perform functionality in a similar manner that is compatible for the inherited parts of SavingsAccount (bank account owner name, open date, balance, etc). This worked because the overloaded operator is not a member function in both the BankAccount and SavingsAccount class, but rather a Free Helper Function. Since it was specified that BankAccount is the base class of the derived class, SavingsAccount, compiler was able to detect the compatability amongst the two helper functions as SavingsAccount is considered a type of BankAccount. However, despite it working well in particular case (note that the read, write and overloaded >> operator was still in place), it is not recommended due to the possibility that the base class may not necessarily be able to provide support to the derived class to a certain extent (i.e. there are additional features / functionality required from base class that would not necessarily behave in a similar manner to an overloaded operator). 

One of the access levels that was learnt is protected. This restricts access amongst the base class and its derived classes only. This was implemented with the BankAccount balance, a private variable. Even though it was private in the BankAccount class, the Query / read-only function that returned that value was protected, which enabled SavingsAccount to gain access to the value through the query, rather than the balance directly. This is best practice to avoid unintentional modifications to a data member that could potentially affect the hierarchy chain and break the code. 

In the first milestone of the project concepts were learnt with format the validation of reading from input stream. In the Time module’s read function, in order to allow only a valid input of time, we were able to control the status of the input, by setting it to a fail bit upon failure to include a : in between two integer type values. With this status set, in the main we were able to handle the bad data entry accordingly without having the program actually crash completely. Rather than requiring to have the colon be entered/stored separately into another variable, I have discovered a way to preview if the : was entered after the hour without having to go through a significant extraction and discard process. The peek method was able to do a check to see if it was already entered by user and discard or set to failbit accordingly. Similarly with the Menu module’s overloaded member >> operator, we were able to make use of failbit in the event a non-integer value was entered by the user. Peek was also utilized to determine correct integer format (i.e. no trailing characters) with less hassle involved. Another useful function learnt was the ignore function and clear function in the overloaded >> member operator as well. This was useful for clearing the buffer / discarding unnecessary input data to ensure it was clean for the re-entry attempt as needed. 

