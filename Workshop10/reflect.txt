In this workshop the concepts learnt involved creating and calling Templates for functions and custom types. These functions have helped with making code more flexible by allowing to work with different Types in the functions. A simple example of this concept being applied can be found in the Pair template for a custom type. The Pairs created do not have any restrictions on the types each object in the Pair can hold.  Similarly for the Pair, addDynamicPairElement, and matches template functions, there were no restrictions on the type of objects that involved the Pairs (given that the elements of the arrays manipulated were of the type Pair from the templated custom type created prior). Likewise, with the releaseMem template function, the type of array that can be deallocated is not restricted to a certain type. These templates have been proven beneficial with their ability to compile the same logic within the functions with different data types. This has been demonstrated in the main function when calling the match template function on multiple occasions. For example, in the first test run, arrays and data types in Pair was of type int and double. But in the sixth test run the same match function was called, but Book and Student data types arrays and pairs were used instead.
